---
title: softwares make me boring
tags: ["software","linux","emacs","vim"]
created: 2026-01-12T16:51:00+08:00
updated: 2026-01-12T16:51:00+08:00
---

# 一种无聊蔓延我身

我是一个技术街溜子，不打算写任何生成性代码。我安装过许多 linux 发行版和许多所谓的开源工具，仅仅是为了好玩。但现在我觉得所有出名的工具我都用过了，并且越发无聊起来。在挖掘这些工具时，我免不了看到社区的各种言论。我只挑三个较为出名的，并且在我看来，这些争吵或者论点的对立本身就没有必要。

## Emacs vs Vi (Vim, Neovim)

这两个工具无法抛弃它们的历史包袱。Emacs 按键很难按，并且还默认自己是在 Lisp 机器；Vi 是事实上的不自洽（试比较 `i`,`a` 、`p`,`P`）。`hjkl` 不管它好不好按，它单纯只是印在终端机上的巧合，结果这种巧合被合理化，以至于 Miryoku（一个键位 mapping，使用 `jkl;`）下面有一个 issue 要求设置 Vim 的上下左右（<https://github.com/manna-harbour/miryoku/issues/44>）。这个 issue 后来被接受了，但是我觉得这么做不太好，因为键位 mapping 是个人的事情。

以及可惜的是它们引以为荣的能力都被市场抛弃了。一个是高度可定制化的解释器环境，一个是 Modal Editing。我觉得我们应该把这两个抽象出来做成一个接近高度定制化的环境（我知道别的语言做不到 Lisp 那样，Elisp 单线程卡得要死），或者一个能用户自定义的 Modal。Neovim 插件这么多，却没人意识到需要修改 Normal 模式。还好有 Helix 这种东西。

说到 Helix，终端编辑器也是感觉不大对头。几乎所有的终端模拟器都遵循 VT100 标准。这意味着它们无法读取实际的按键。今年 2026 年了，Emacs 应该是一个更为广泛使用的软件和生产环境（由于它的生态以及 Robust），而 Vim 系应该是可以在 Kitty 终端新协议下发扬光大能看图片的编辑器。但是事实是一个困在了慢和学习曲线中，一个困在了 VT100 中。

## 约定 vs 配置

AKA 开箱即用 vs「我需要自己的配置环境」。Neovim 不能修改 Modal 我就不说了。至于 Emacs，在 Windows 上较慢，而 Windows 是全世界最多用户的系统。可能 WSL 会解决一部分问题，不过先不管这两个，我想提到的是 Worse is better 的事情。

Org-mode 本来是一个非常好非常完善的标记语言，它自己单开一个都能生活得很好，但是不知道为什么它总是逃离不开它的生态，导致被一个无结构化无 Syntax 并且最初目的是一个易写 HTML 而不是作为 DB 存储的轻量标记语言占了上风。哦对了说到这个，几乎所有 Markdown 方言的软件它写的方言几乎和它的软件是强绑定的，而 Obsidian 是一个 Chromium 软件，它一万字就开始卡了。不过好在它足够铺开，这让别的 GUI 编辑器还能读出它的文件。可能 Logseq 的思路比较好，虽然它一点也不成熟。

一个标记语言，它的命运居然取决于它寄生在哪个编辑器上，这本身就很能说明工具在设定边界上的问题了。

## Windows vs Linux

我需要向你强调，今年是 2026 年，今天是一月份的某一天，这两个东西又吵起来了，因为 Windows 新加了那个什么 AI，并且 `explorer.exe` 非常慢，微软甚至决定 preload。macOS 新加的视觉效果又卡又慢，默认的 Finder 还开始找不到软件。

`explorer.exe` 的设计是非常奇怪的，居然把任务栏也给管上了，只要线程崩溃，我连文件复制粘贴都找不到是否成功。然后一大把 Linux 使用者开始说 Windows 是烂系统，你看我们 Linux 打开文件又快。到这一部分我觉得 Linux 使用者说的没什么问题（除开这个「快」并没有包括「桌面环境」会在 NVIDIA 时不时崩溃的因素，哈哈）。

我其实受不了的是 Linux 使用者说美化多好多方便。绝大多数 Unixporn 都有 Anime Girl Wallpaper，然而这些 Anime Girl 大概率是由画师在又蠢又慢的 CSP 下画出的，而 CSP 是一个 Windows 独占软件。我觉得这是一种比较荒谬的行为，仅仅是因为他们是精神胜利的消费者。消费工具的开源和简洁，让他们忽略画师在 CSP 作画，我感觉就是现代版的何不食肉糜了。

这不是 yet another「你看又被专有软件控制住了吧哈哈 Windows 用户」的吐槽，这个吐槽常常和「哎呀我平时大部分都是做一些文本处理工作所以使用 Linux 就满意了！！」结合使用，仅仅是为了反驳「那么，专有软件呢？」。以前这个门槛是游戏。现在游戏的门槛逐渐降低了（因为 Wayland 的崛起，而 Proton 愈发成熟），Linux 使用者就又想方设法来让更多人使用 Linux。我需要提到的是：这是一种生活态度问题，和是否专有软件没什么太大关系。文字处理工作是 solved problem，别的不是。我并不是要否认 Linux 的宣传方式。让更多的人，我的意思是，各行各业的人，使用上 Linux，在理想情况下是一个好事。我只是说这个好事发生得没那么早。

当遇到有人吹 Linux 美化时（像类似于「我使用 Linux，我的系统更快更好更漂亮了！！！所有的组件都可以根据这个 Anime Girl Wallpaper 来生成颜色，而不像 Windows 那样固定又死板连系统的字体都改不了！！」这种感觉），我觉得一种正确的思考方式就是，为什么还有成千上万的 Artists 还需要饱受 Windows 的长期折磨，而目前的情况看，这像是许多人享受钻石带来的附加价值，但是非洲仍然连正常的水源都没有。

我相信许多人关注 Adult Artists 完全是因为这帮助到他们 Masturbation。我没见到我喜欢的画师在 Linux 上作画，也没有人在 Linux 上面做 3D Anime Adult Vid。「不，Krita 不是也能做画吗？」当然，但是粉丝数就能说明这件事。我在这里不是单纯地比较，而是人类贡献问题。粉丝数多的 Adult Artists，它就是帮助更多人获得快感。况且，如果有一个粉丝数多的人使用 Krita，那么他早该在推特上大声宣扬了。如果 Windows 真的灭绝了，对人类快感的贡献直接少了一大截。这听起来像滑坡谬误，但是事实是可能真的是这样。你可以向许多文字工作者推荐 Linux，但是你可能永远不能说服其他群体：「今年是 Linux 元年，你们应该使用 Linux 来做片了」，尤其是这个群体是那种能最直接地给人带来快乐的群体。

我看过 Tsoding 的视频，他觉得 Rust 的教程太多营销了，这些带有营销的教程不断地在说 Rust 是一种多么好的语言，他觉得这是在欺骗你学下去这个 Shit Language。我不会说 Linux 是一个 Shit System，因为它在服务器上无人能敌，但是一种类似的情况是，如果一个 Artist 在用 Linux，他早就在推特上一直宣传自己使用 Linux 作画了，而不是等到一种风头正盛的时候才跳出来说「I'm using Linux btw」。

## 选择你的傲慢与偏见

我最终发现一种可能大一统这三个局面的事情那就是：

1. 没有选择只有代价。
2. 由 1 得知选择了一种选择意味着认同这种代价较小。
3. 人都爱合理化自己的行为。
4. 由 2、3 得知人不仅会认同并逐渐无视我选择的代价（小或无），还会反对另外一种选择的代价。
5. 4 其实是傲慢。
6. 5 得知：有选择，而选择是有代价的，而这个代价其实就是傲慢本身。这可能和 1 矛盾。但是是推导出来的。

Emacs 的代价就是无数的人小拇指痛。Meow 算是合理的（它的默认行为是 Modal，不过我的理解是它是一种附着在软件默认行为上的 layer）。Evil 被吐槽过无数次又慢又没太多普适性。许多人可能有无视手痛的天赋，但是我没有。

Vi 或者一众 TUI 编辑器使得俄语键盘使用者无法给祖母写信。他们只能切换英语键盘，仅仅只是为了移动光标。中文需要多按键切换中英文。不算少数的群体，废了那么大的劲，仅仅只是为了做一个和英语世界单键就能处理的行为，而这是低优先级 Issue。TUI 编辑器会说「这不关我事这是你的终端编辑器是 VT100 标准等 VT100 标准不用了我们再用别的吧」。终端模拟器会说「别的终端模拟器都在用 VT100 标准我们也得用啊」。其实两边都是事实，并且在技术上是正确的，只是这又绕回来了：Emacs 的开发者也不在乎所有人能不能记住 `C-n` `C-p`。他们只需要他们自己技术够好就行了。这个东西的本质上不是技术问题，是谁的痛苦被忽略的问题。

Windows 使用者的傲慢就是他们经常不去理解系统底层行为，并且总是做出一些程序上很蠢的操作，比如询问为什么不支持 Windows？为什么不给我 `.exe`？

Linux 使用者的傲慢就是除了文字处理之外 Linux 其实很多时候无能为力，在这里文字处理包括 Coding。没有专用软件，就无法预览装修房子，无法做出工业级别的 Anime Girl 插画。

---

## 灵感来源

### Xahlee - 40 keys keyboard

<http://xahlee.info/kbd/40percent_keyboard_bad.html>

这是一个讲解了 40 键盘有多么没用的暴论文章。

```md
## Nerd in a Rut

These people are nerds in a rut. A creation rut, blind to the general purpose or goal of what keyboard layout is, digging a special grave for themselfs. To them, they think are creative. They create things nobody else can use. No value to the general public. And even among us nerds who build DIY keyboards and use dvorak layout, 90% of us will not find their creation useful.
```

### Xahlee - Emacs 和 Vim 键位

这两篇文章分别喷了 emacs 和 vi 的快捷键。我不在这里分辨他说的历史是否是 cherry-picked 的，但是这对我的思考确实有帮助。

<http://xahlee.info/emacs/emacs/emacs_kb_shortcuts_pain.html>

<http://xahlee.info/emacs/emacs/vi_vim_pile_of_history.html>

### tsoding 视频

<https://www.youtube.com/watch?v=TB2wqzGSsqM>

```text
00:00 :: So, speaking of the, like, how I notice that every time I stream Rust, and a lot of people complain about how unreadable it is. It actually reminded me some interesting thread on Reddit that I saw the other day, where people were asking: is there any, like, Rust tutorials or Rust YouTube videos where the person who's explaining how to do things in Rust doesn't try to constantly sell the language?

00:30 :: So the thing about all of the Rust tutorials is that the people who do them, they not only give you like the information how to use the language and stuff like that, but they constantly trying to tell you how great the language is, like non-stop. "It's a great language. It's a great language. It's a great language."

00:48 :: And apparently a lot of Rust developers find it annoying. They just want to find like a video where they talk about Rust, but without trying to constantly sell it. And I telling you, it is impossible. Because to actually convince you that this is a good language, you have to be constantly blasted with propaganda, which confirms my point. Because if you're not constantly blasted with propaganda that this is a good language, you wouldn't fucking program in it, because it's ffucking horrible. Like you constantly need to hear like, "It's a good language, it's a good language, it's a good language."

01:18 :: It is so ffucking funny that the even Rust developers themselves, like saying that. Like it's just like, "Could you please stop selling the language?" No, you can't stop selling the language! Otherwise you're not going to be programming in it. Like, you need to constantly sell Rust, otherwise the language will die. It will just die. Nobody wants to program in it.

01:42 :: Anyways, anyways, anyways. (Reading Chat) "Well, they have to see your videos." Well, I mean a lot of people get mad at my videos because I don't say good things about Rust, which is kind of like the opposite problem.

02:01 :: (Reading Chat) "This is the same with Neovim nowadays." Really? People also blasting like other people with constant propaganda with Neovim? I don't know.
```

### 俄国人无法给祖母写信

<https://www.youtube.com/watch?v=tvlupFXjqpQ>

这个视频展示了在打出 `Привет, дорогая бабушка!` 之后，俄语使用者想按下 `Ctrl + [` 退出 insert mode，但是只能打出来西里尔字母 "х" (kha)：`Привет, дорогая бабушка!ххххххххх`。他的标题取名为 `Terminal text editors are a dead end`，社区的人有些评价他是 Crazy Click-bait。其实这还挺让人绝望的，因为一个视频，你不用 Click-bait 吧，又没人关注 Issue，用 Click-bait 吧又要给人说。

```text
00:00 :: If you watch this on YouTube, you probably already guessed it. I am, of course, talking about keyboard layouts. And, well, before Rust people start attacking me that I am going after Helix, actually no. This is an issue with all terminal text editors, and I will demonstrate it on actually Neovim.

00:21 :: Yeah, so, if I open Neovim here... just let me demonstrate the issue. I go into insert mode, and let's say I want to write a letter to my Babushka. And of course, she doesn't speak English, so I will type it in Russian. Right, so: "Hello, my dear grandma."

00:49 :: Right, so, I'm... you know, I'm done. And then I decide to... actually I don't want to say "Hello," I want to say something else. And then I try to go back into normal mode, and it doesn't work.

01:05 :: Right, so I am pressing Control + Left Bracket. And see here, I have like an input display—it's like a little bit scuffed but you can kind of see that this is a Control. Right, so I'm pressing Left Bracket. Physical keyboard key. But Neovim for some reason inserts Russian "х" (kha). Why is that?

01:23 :: So if I press Escape—like actual physical Escape—and I try to navigate backwards by pressing 'h', you can also see that nothing happens. Neovim just doesn't work. Only if I go back to English layout, now I can do stuff. Right. So this is what I mean.

01:45 :: And, yeah, so this is not an issue with only Helix. This is not an issue with only Neovim. This is actually an issue with all terminal programs. So why is that?

01:57 :: The reason is that terminal text editors—or for the matter of fact, all terminal programs that don't do any sort of special operating system hacks—they don't actually have an ability to see what physical keyboard keys you are pushing on your keyboard. Because your text editor is not a native program. It is a terminal program.

02:24 :: The program that receives physical keys is your terminal emulator. In my case it's Alacritty, but it's absolutely the same with Ghostty or any really other text editors... uh, sorry, terminal emulators.

02:38 :: So, terminal emulator will receive actual physical keyboard keys, and then it has to adhere to this VT100 standard—whatever it's called—and it will pass actual characters to your terminal program as if the user would type them into the terminal themselves, right?

02:58 :: And so your text editor, instead of receiving physical keyboards [keys] as registered by an operating system, your terminal emulator... sorry, it's 1:00 AM, right, I'm recording this... your text editor receives characters from the terminal emulator as if your terminal emulator would literally just pipe them into it.

03:22 :: And that's why text editors have no way—well, no reasonable, legal way—to know which key you actually pressed. And so it kind of has to guess based on some kind of a hardcoded set of bindings it has.

03:39 :: So for example, Neovim knows that letter 'h' is left, letter 'l' is right. And it's not physical 'l' and 'h' keys. It's actually ASCII letter 'h' and ASCII letter 'l', which in different keyboard layouts exist on different places.

04:00 :: And so we have this issue in Helix where... not Russian, but a German user complains about the same pretty much stuff. And you know, the workaround is: "Oh, you can maybe remap like umlaut to the same keybinding, have two different keybindings for the same action."

04:20 :: And that's actually the only reasonable workaround text editors have. So for example, what does Neovim offer? Well, Neovim has this langmap feature. Right, so... this thing. Which allows you to set a language map for each character to your native language, so that when you are in insert mode—or I guess in normal mode—your key codes get mapped to English and they sort of work.

04:56 :: Why they "sort of" work? Because this thing... it's... it's really brittle. So let me actually show you. Right, so prepare for the flashbang. So here is Neovim documentation for Russian language. And they actually give you the langmap you need to assign for the thing.

05:15 :: So if I copy it... and let me actually paste it, and it has to be on one line... and then, right, I'll just paste it here and I apply it. Now I have a... I have this langmap.

05:27 :: And now if I go to insert mode and start writing in Russian... and press Escape... I can actually press—so this is me pressing Russian letters—and it kind of sort of works, right? But if I go back to insert mode and I try to press Escape with Control + Left Bracket, you see it still doesn't work.

05:50 :: Because well, first, the letter "х" (kha), it's not mapped in this official langmap to Left Bracket. And second, there's actually a bunch of issues with it. Uh, right, this is Neovim source code... this is also Neovim source code... and this is Neovim source code... but where is it?

06:07 :: Yeah, there it is. And... no, this is also not it. Well maybe I... yeah I guess that's the one. And yeah, this is the issue I was talking about: "Improve langmap for non-English keyboards." And it's 10 years old. And there are people kind of discussing what sort of workarounds they can add, you know, to maybe handle more of these cases, more of the edge cases for more languages. And it's kind of discussion, discussion, discussion... and right, at some point the issue kind of died.

06:44 :: The thing is, this particular design flow, it's literally unfixable. I guess unless you violate all of the, you know, security best practices and start reading inputs directly from the kernel. Which you actually can do, right?

06:58 :: If we go look at the... this is Linux kernel source code... uh, it is... you can see user/include/linux. This is input-event-codes.h. And Linux sends you these scan codes. These are actual physical key codes. Like, they are called KEY_Q, QWERTY, for kind of QWERTY keyboard layout, but no matter in which keyboard layout you are, you will always receive these consistent key codes.

07:30 :: And so actual GUI programs, right? So if you open Gedit or KWrite or even Visual Studio Code, they don't care about your keyboard layout. Their hotkeys just work because they have this information. Unlike terminal text editors.

07:47 :: And what do we have if we only have terminal? Well, we have these kind of brittle workarounds. And interesting that this issue "Better support for international keyboards" was actually closed because... um, there was also additional pull request that basically proposed the same exact workaround as in Neovim case, right? So just literally map Russian letters to like English letters. And let's hope whatever Russian uses the keyboard doesn't have like Dvorak layout where everything is mixed up, right?

08:26 :: So, and this was actually closed in favor of... Helix becoming an Emacs. [Laughter] So there was no other way for Helix to fix this issue as to switch to a Lisp configuration language, so that maybe plugin developers can handle this issue somewhat automatically, right?

08:52 :: This is what kind of level of effort we are talking about. And everything is because terminal programs don't have a way to know physical key presses on your physical keyboards. That's why the title: Yes, it is an evolutionary dead end. It is unreliable. But I guess if you only care about English language and if you don't speak any other language, you don't even notice it.

09:22 :: So, yeah. That's... that's the video. Yeah. Uh, if you want to learn how to get actual physical keyboards... uh, physical key [inputs]... I can record a tutorial, but I don't know, maybe sometime later. Anyway, thanks.
```
